<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Alloc - A Basic Malloc Implementation | The Shade</title>
    <link rel="icon" type="image/png" href="/assets/images/flavicon/TheShade.png" />
    <link rel="stylesheet" href="/assets/style.css" />
  </head>
  <body>
    <header>
      <img class="site-icon" src="/assets/images/flavicon/TheShade.png" alt="Site Icon">
      <h1><a href="/">The Shade</a></h1>
      <nav>
        <a href="/blog">Blog</a>
        <a href="/about">About</a>
      </nav>
    </header>

    <main>
      <article class="post">
  <h1>Alloc - A Basic Malloc Implementation</h1>
  <p class="post-date">November 21, 2025</p>
  <div class="post-content">
    <h2 id="high-level-understanding-of-malloc">High Level Understanding Of Malloc</h2>

<h3 id="memory-layout-of-a-process">Memory Layout Of A Process</h3>

<div style="text-align:center;">
  <img src="/assets/images/alloc/MallocHeaderLayout.png" alt="Memory Layout PNG" style="width:60%; max-width:600px; height:auto;" />
</div>

<p>Before diving into what Malloc is, it’s important to paint the picture of how your program, or any process executing on your machine (for most standard operating systems), is laid out in memory. As seen in the graphic above, the memory layout consists of four main parts. The Text and Data represent the executable machine instructions and initialized global and static variables respectively. Unlike the Stack and Heap, these portions do not expand at runtime. The Stack and Heap represent portions of the memory layout that are far more complicated than the Text and Data portions. The Stack is used to establish variables’ lifetimes. Meaning, any local variables, function parameters, return addresses, etc. are placed into stack frames and help a process establish their lifetime within a program. Alternatively, the Heap represents dynamically allocated memory within a program, meaning memory that can outlast a single stack frame.</p>

<h3 id="what-the-hell-is-virtual-memory">What The Hell is Virtual Memory?</h3>

<p>Surprisingly, virtual memory is not your elders getting scammed into downloading RAM off of a shady website. Instead, virtual memory has to do with the concept of virtualization. In operating systems virtualization is how an operating system provides the illusion of isolation for processes when interacting with hardware. More specifically, have you ever wondered how your computer is able to keep open 15 Chrome tabs, Discord, and Zoom? Well, ignoring multicore CPUs, this has to do with virtualizing your CPU! Virtualizing your CPU means that despite only having one CPU, your operating system provides the illusion that each process has “its own CPU”. With that being said, your operating system does a similar process with your RAM. Your RAM has one physical address space, however your operating system translates this physical address space into a contiguous virtual address space, or virtual memory for each process.</p>

<h3 id="so-what-is-malloc-then">So What Is Malloc Then…</h3>

<p>Malloc, and its corresponding function free, are simply C functions that abstract virtual memory management from the programmer. For example, if you call malloc with a certain amount of bytes, you do not have to worry about whether your current heap size is of size to accommodate that request, as malloc handles that for you. Additionally, when you ultimately (hopefully) free this pointer, malloc will free this block of memory and mark it as reusable, allowing you to reuse heap memory you previously allocated.</p>

<h3 id="diving-into-the-mechanics-of-malloc-basic-implementation">Diving Into The Mechanics Of Malloc (Basic Implementation)</h3>

<h4 id="initially-calling-malloc">Initially Calling Malloc</h4>

<p>The first time you call Malloc, your heap will be of a predetermined size by your operating system. So, if your memory request exceeds this initial amount malloc will call sbrk. Sbrk is a system call that will expand the upper bound of your heap memory. If this system call is successful, then Malloc will return a void pointer to you at the start of a heap address of the size of your request.</p>

<h4 id="so-what-about-when-you-free-this-memory">So What About When You Free This Memory?</h4>

<p>When you call free on this memory pointer, I remember thinking how does free know how long the passed-in pointer is? There is no easy, inherent way to know the size of a block of data given only a pointer, so Malloc and Free work together by utilizing Malloc headers and the free list.</p>

<h4 id="what-is-this-malloc-header-and-free-list-you-are-talking-about">What Is This Malloc Header And Free List You Are Talking About?</h4>

<p>Jumping back to when you initially call malloc, there is a sneaky step I originally left out and is unbeknownst to an unsuspecting user. When Malloc hands you a void pointer to your memory, the memory immediately preceding your void pointer is a Malloc header. As shown in the graphic above, the Malloc header includes important information, such as the size of the preceding block of memory, overwrite protection checks, and helps map out your virtual address space. This allows free to “jump back” in memory the size of the malloc header and read important metadata. <br /></p>

<p>So, now that you understand what a malloc header is and how it helps map out the virtual address space, what is a free list? Well, when you free that block of memory, that malloc header is placed as a node in a linked list (at least in this simple implementation) in ascending order based on the virtual memory address they point to. This allows the free list to coalesce blocks. Meaning, if there are free blocks adjacent in memory to one another these merge to form a large block, preventing fragmentation of memory. These free blocks are then utilized by malloc in future calls as potential addresses of memory that can be used. If the size of the request can fit within a free node on a free list, that memory is used and potentially split based on the size of the request.</p>

<h2 id="what-i-learned-from-implementing-this">What I Learned From Implementing This</h2>

<p>Amongst the core concepts of CS I learned from this, what I particularly was taken aback by was just how much is truly abstracted from programmers. The OS truly provides these “sandboxes” your processes/programs live in in which you do not have to worry about much. Even further, I primarily code in Python as an MLE.. which takes care of heap allocation and garbage collection for you. The true abstraction that occurs in these languages and operating systems is very impressive and hides a lot of knowledge from you. However, while languages like Python abstract these things from you, knowing how these processes work under the hood is still very helpful. This knowledge can help you write more performant code, in addition to understanding errors and “weird” occurrences in your code that you would otherwise be blind to.</p>

<p>If you are interested in seeing my implementation of malloc, please see here.</p>

<p><a href="https://github.com/AndrewJMart/A-lloc">https://github.com/AndrewJMart/A-lloc</a></p>

  </div>
</article>

    </main>

    <footer>
      <p>
        <a href="https://github.com/AndrewJMart" target="_blank">GitHub</a> •
        <a href="https://www.linkedin.com/in/andrewjmart" target="_blank">LinkedIn</a> •
        <a href="https://x.com/AndrewJMartOnX" target="_blank">Twitter/X</a>
      </p>
      <p>© 2025 Andrew Martinez</p>
    </footer>
  </body>
</html>